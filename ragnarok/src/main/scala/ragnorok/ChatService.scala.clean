package ragnorok

import cats.effect.{IO, Resource}
import cats.effect.std.Queue
import cats.implicits._
import fs2.Stream
import fs2.concurrent.Channel
import io.circe.generic.auto._
import io.circe.syntax._
import org.http4s.{HttpRoutes, MediaType, Response}
import org.http4s.dsl.Http4sDsl
import org.http4s.server.websocket.WebSocketBuilder2
import org.typelevel.log4cats.Logger

import java.util.UUID
import scala.jdk.CollectionConverters._

case class ChatRequest(question: String)
case class ChatStreamResponse(content: String, references: List[String] = Nil)

object ChatStreamResponse {
  def toEventString(response: ChatStreamResponse): String =
    s"data: ${response.asJson.noSpaces}\n\n"
}

class ChatService(assistant: Assistant, contentRetriever: ContentRetriever) {
  private val dsl = new Http4sDsl[IO] {}
  import dsl._


  def routes(implicit logger: Logger[IO]): HttpRoutes[IO] =
    HttpRoutes.of[IO] { case req @ POST -> Root / "chat" =>
      logger.info("Received chat request") *> {
        for {
          chatReq <- req.as[ChatRequest]
          channel <- Channel.unbounded[IO, String]
          
          // Start the chat stream in the background
          _ <- IO {
            val stream = assistant.chat(chatReq.question)
            
            stream
              .onPartialResponse { token =>
                val data = token.replace("\n", "\\n")
                val event = s"data: $data\n\n"
                channel.send(event).unsafeRunAndForget()
              }
              .onCompleteResponse { _ =>
                channel.send("data: [DONE]\n\n").unsafeRunAndForget()
                channel.close.attempt.void.unsafeRunAndForget()
              }
              .onError { error =>
                channel.send(s"event: error\ndata: ${error.getMessage}\n\n").unsafeRunAndForget()
                channel.close.attempt.void.unsafeRunAndForget()
              }
              .start()
              .void
          }.start
          
          // Start the retrieval in the background
          _ <- IO {
            val query = Query.from(chatReq.question)
            val relevantContent = contentRetriever.retrieve(query)
            val references = relevantContent.asScala.toList.flatMap { content =>
              val metadata = content.textSegment().metadata()
              val path = Option(metadata.getString("file_name")).getOrElse("unknown")
              if (path != "unknown") Some(path) else None
            }.distinct
            
            // Log the references
            logger.info(s"Found references: ${references.mkString(", ")}").unsafeRunAndForget()
            
            // Send references as a separate event
            val refsEvent = ChatStreamResponse("", references)
            channel.send(ChatStreamResponse.toEventString(refsEvent)).unsafeRunAndForget()
          }.handleErrorWith { error =>
            logger.error(error)("Error during retrieval") *> 
            channel.send(s"event: error\ndata: ${error.getMessage}\n\n") *>
            channel.close.attempt.void
          }
          
          // Return the response
          response <- Ok(channel.stream)
            .map(_.withContentType(MediaType.`text/event-stream`))
            .handleErrorWith { error =>
              logger.error(error)("Error in chat stream") *>
              InternalServerError(s"Error: ${error.getMessage}")
            }
        } yield response
      }
    }
}

object ChatService {
  def create(assistant: Assistant, contentRetriever: ContentRetriever): ChatService =
    new ChatService(assistant, contentRetriever)
}
